"use strict";

var helpers = require("../../node_modules/@parcel/transformer-react-refresh-wrap/lib/helpers/helpers.js");

var prevRefreshReg = window.$RefreshReg$;
var prevRefreshSig = window.$RefreshSig$;
helpers.prelude(module);

try {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.toast = void 0;

  var React = _interopRequireWildcard(require("react"));

  var _reactDom = require("react-dom");

  var _utils = require("../utils");

  var _eventManager = require("./eventManager");

  var _components = require("../components");

  var _jsxFileName = "C:\\Users\\Shivansh\\Codebase\\material-react-toastify\\src\\core\\toast.tsx";

  function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

  function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

  let containers = new Map();
  let latestInstance;
  let containerDomNode;
  let containerConfig;
  let queue = [];
  let lazy = false;
  /**
   * Check whether any container is currently mounted in the DOM
   */

  function isAnyContainerMounted() {
    return containers.size > 0;
  }
  /**
   * Get the container by id. Returns the last container declared when no id is given.
   */


  function getContainer(containerId) {
    if (!isAnyContainerMounted()) return null;
    return containers.get(!containerId ? latestInstance : containerId);
  }
  /**
   * Get the toast by id, given it's in the DOM, otherwise returns null
   */


  function getToast(toastId, {
    containerId
  }) {
    const container = getContainer(containerId);
    if (!container) return null;
    return container.getToast(toastId);
  }
  /**
   * Generate a random toastId
   */


  function generateToastId() {
    return (Math.random().toString(36) + Date.now().toString(36)).substr(2, 10);
  }
  /**
   * Generate a toastId or use the one provided
   */


  function getToastId(options) {
    if (options && ((0, _utils.isStr)(options.toastId) || (0, _utils.isNum)(options.toastId))) {
      return options.toastId;
    }

    return generateToastId();
  }
  /**
   * If the container is not mounted, the toast is enqueued and
   * the container lazy mounted
   */


  function dispatchToast(content, options) {
    if (isAnyContainerMounted()) {
      _eventManager.eventManager.emit(_eventManager.Event.Show, content, options);
    } else {
      queue.push({
        content,
        options
      });

      if (lazy && _utils.canUseDom) {
        lazy = false;
        containerDomNode = document.createElement('div');
        document.body.appendChild(containerDomNode);
        (0, _reactDom.render)( /*#__PURE__*/React.createElement(_components.ToastContainer, _extends({}, containerConfig, {
          __self: this,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 90,
            columnNumber: 14
          }
        })), containerDomNode);
      }
    }

    return options.toastId;
  }
  /**
   * Merge provided options with the defaults settings and generate the toastId
   */


  function mergeOptions(type, options) {
    return { ...options,
      type: options && options.type || type,
      toastId: getToastId(options)
    };
  }

  const toast = (content, options) => dispatchToast(content, mergeOptions(_utils.TYPE.DEFAULT, options));

  exports.toast = toast;

  toast.success = (content, options) => dispatchToast(content, mergeOptions(_utils.TYPE.SUCCESS, options));

  toast.info = (content, options) => dispatchToast(content, mergeOptions(_utils.TYPE.INFO, options));

  toast.error = (content, options) => dispatchToast(content, mergeOptions(_utils.TYPE.ERROR, options));

  toast.warning = (content, options) => dispatchToast(content, mergeOptions(_utils.TYPE.WARNING, options));

  toast.dark = (content, options) => dispatchToast(content, mergeOptions(_utils.TYPE.DARK, options));
  /**
   * Maybe I should remove warning in favor of warn, I don't know
   */


  toast.warn = toast.warning;
  /**
   * Remove toast programmaticaly
   */

  toast.dismiss = id => isAnyContainerMounted() && _eventManager.eventManager.emit(_eventManager.Event.Clear, id);
  /**
   * Clear waiting queue when limit is used
   */


  toast.clearWaitingQueue = (params = {}) => isAnyContainerMounted() && _eventManager.eventManager.emit(_eventManager.Event.ClearWaitingQueue, params);
  /**
   * return true if one container is displaying the toast
   */


  toast.isActive = id => {
    let isToastActive = false;
    containers.forEach(container => {
      if (container.isToastActive && container.isToastActive(id)) {
        isToastActive = true;
      }
    });
    return isToastActive;
  };

  toast.update = (toastId, options = {}) => {
    // if you call toast and toast.update directly nothing will be displayed
    // this is why I defered the update
    setTimeout(() => {
      const toast = getToast(toastId, options);

      if (toast) {
        const {
          props: oldOptions,
          content: oldContent
        } = toast;
        const nextOptions = { ...oldOptions,
          ...options,
          toastId: options.toastId || toastId,
          updateId: generateToastId()
        };
        if (nextOptions.toastId !== toastId) nextOptions.staleId = toastId;
        const content = typeof nextOptions.render !== 'undefined' ? nextOptions.render : oldContent;
        delete nextOptions.render;
        dispatchToast(content, nextOptions);
      }
    }, 0);
  };
  /**
   * Used for controlled progress bar.
   */


  toast.done = id => {
    toast.update(id, {
      progress: 1
    });
  };
  /**
   * Track changes. The callback get the number of toast displayed
   *
   */


  toast.onChange = callback => {
    if ((0, _utils.isFn)(callback)) {
      _eventManager.eventManager.on(_eventManager.Event.Change, callback);
    }

    return () => {
      (0, _utils.isFn)(callback) && _eventManager.eventManager.off(_eventManager.Event.Change, callback);
    };
  };
  /**
   * Configure the ToastContainer when lazy mounted
   */


  toast.configure = (config = {}) => {
    lazy = true;
    containerConfig = config;
  };

  toast.POSITION = _utils.POSITION;
  toast.TYPE = _utils.TYPE;
  /**
   * Wait until the ToastContainer is mounted to dispatch the toast
   * and attach isActive method
   */

  _eventManager.eventManager.on(_eventManager.Event.DidMount, containerInstance => {
    latestInstance = containerInstance.containerId || containerInstance;
    containers.set(latestInstance, containerInstance);
    queue.forEach(item => {
      _eventManager.eventManager.emit(_eventManager.Event.Show, item.content, item.options);
    });
    queue = [];
  }).on(_eventManager.Event.WillUnmount, containerInstance => {
    containers.delete(containerInstance.containerId || containerInstance);

    if (containers.size === 0) {
      _eventManager.eventManager.off(_eventManager.Event.Show).off(_eventManager.Event.Clear).off(_eventManager.Event.ClearWaitingQueue);
    }

    if (_utils.canUseDom && containerDomNode) {
      document.body.removeChild(containerDomNode);
    }
  });

  helpers.postlude(module);
} finally {
  window.$RefreshReg$ = prevRefreshReg;
  window.$RefreshSig$ = prevRefreshSig;
}