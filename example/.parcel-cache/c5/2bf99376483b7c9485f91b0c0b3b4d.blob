"use strict";

var helpers = require("../../node_modules/@parcel/transformer-react-refresh-wrap/lib/helpers/helpers.js");

var prevRefreshReg = window.$RefreshReg$;
var prevRefreshSig = window.$RefreshSig$;
helpers.prelude(module);

try {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.useToast = useToast;

  var _react = require("react");

  var _utils = require("../utils");

  var _useKeeper = require("./useKeeper");

  function getX(e) {
    return e.targetTouches && e.targetTouches.length >= 1 ? e.targetTouches[0].clientX : e.clientX;
  }

  function getY(e) {
    return e.targetTouches && e.targetTouches.length >= 1 ? e.targetTouches[0].clientY : e.clientY;
  }

  function useToast(props) {
    const [isRunning, setIsRunning] = (0, _react.useState)(true);
    const [preventExitTransition, setPreventExitTransition] = (0, _react.useState)(false);
    const toastRef = (0, _react.useRef)(null);
    const drag = (0, _useKeeper.useKeeper)({
      start: 0,
      x: 0,
      y: 0,
      deltaX: 0,
      removalDistance: 0,
      canCloseOnClick: true,
      canDrag: false,
      boundingRect: null
    });
    const syncProps = (0, _useKeeper.useKeeper)(props, true);
    const {
      autoClose,
      pauseOnHover,
      closeToast,
      onClick,
      closeOnClick
    } = props;
    (0, _react.useEffect)(() => {
      if ((0, _utils.isFn)(props.onOpen)) props.onOpen( /*#__PURE__*/(0, _react.isValidElement)(props.children) && props.children.props);
      return () => {
        if ((0, _utils.isFn)(syncProps.onClose)) syncProps.onClose( /*#__PURE__*/(0, _react.isValidElement)(syncProps.children) && syncProps.children.props);
      };
    }, []);
    (0, _react.useEffect)(() => {
      props.draggable && bindDragEvents();
      return () => {
        props.draggable && unbindDragEvents();
      };
    }, [props.draggable]);
    (0, _react.useEffect)(() => {
      props.pauseOnFocusLoss && bindFocusEvents();
      return () => {
        props.pauseOnFocusLoss && unbindFocusEvents();
      };
    }, [props.pauseOnFocusLoss]);

    function onDragStart(e) {
      const toast = toastRef.current;
      drag.canCloseOnClick = true;
      drag.canDrag = true;
      drag.boundingRect = toast.getBoundingClientRect();
      toast.style.transition = '';
      drag.start = drag.x = getX(e.nativeEvent);
      drag.removalDistance = toast.offsetWidth * (props.draggablePercent / 100);
    }

    function onDragTransitionEnd() {
      if (drag.boundingRect) {
        const {
          top,
          bottom,
          left,
          right
        } = drag.boundingRect;

        if (props.pauseOnHover && drag.x >= left && drag.x <= right && drag.y >= top && drag.y <= bottom) {
          pauseToast();
        } else {
          playToast();
        }
      }
    }

    function playToast() {
      setIsRunning(true);
    }

    function pauseToast() {
      setIsRunning(false);
    }

    function bindFocusEvents() {
      window.addEventListener('focus', playToast);
      window.addEventListener('blur', pauseToast);
    }

    function unbindFocusEvents() {
      window.removeEventListener('focus', playToast);
      window.removeEventListener('blur', pauseToast);
    }

    function bindDragEvents() {
      document.addEventListener('mousemove', onDragMove);
      document.addEventListener('mouseup', onDragEnd);
      document.addEventListener('touchmove', onDragMove);
      document.addEventListener('touchend', onDragEnd);
    }

    function unbindDragEvents() {
      document.removeEventListener('mousemove', onDragMove);
      document.removeEventListener('mouseup', onDragEnd);
      document.removeEventListener('touchmove', onDragMove);
      document.removeEventListener('touchend', onDragEnd);
    }

    function onDragMove(e) {
      const toast = toastRef.current;

      if (drag.canDrag) {
        if (isRunning) pauseToast();
        drag.x = getX(e);
        drag.deltaX = drag.x - drag.start;
        drag.y = getY(e); // prevent false positif during a toast click

        if (drag.start !== drag.x) drag.canCloseOnClick = false;
        toast.style.transform = `translateX(${drag.deltaX}px)`;
        toast.style.opacity = `${1 - Math.abs(drag.deltaX / drag.removalDistance)}`;
      }
    }

    function onDragEnd() {
      const toast = toastRef.current;

      if (drag.canDrag) {
        drag.canDrag = false;

        if (Math.abs(drag.deltaX) > drag.removalDistance) {
          setPreventExitTransition(true);
          props.closeToast();
          return;
        }

        toast.style.transition = 'transform 0.2s, opacity 0.2s';
        toast.style.transform = 'translateX(0)';
        toast.style.opacity = '1';
      }
    }

    const eventHandlers = {
      onMouseDown: onDragStart,
      onTouchStart: onDragStart,
      onMouseUp: onDragTransitionEnd,
      onTouchEnd: onDragTransitionEnd
    };

    if (autoClose && pauseOnHover) {
      eventHandlers.onMouseEnter = pauseToast;
      eventHandlers.onMouseLeave = playToast;
    } // prevent toast from closing when user drags the toast


    if (closeOnClick) {
      eventHandlers.onClick = e => {
        onClick && onClick(e);
        drag.canCloseOnClick && closeToast();
      };
    }

    return {
      playToast,
      pauseToast,
      isRunning,
      preventExitTransition,
      toastRef,
      eventHandlers
    };
  }

  helpers.postlude(module);
} finally {
  window.$RefreshReg$ = prevRefreshReg;
  window.$RefreshSig$ = prevRefreshSig;
}