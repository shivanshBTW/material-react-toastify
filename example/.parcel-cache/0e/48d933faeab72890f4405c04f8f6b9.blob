"use strict";

var helpers = require("../../node_modules/@parcel/transformer-react-refresh-wrap/lib/helpers/helpers.js");

var prevRefreshReg = window.$RefreshReg$;
var prevRefreshSig = window.$RefreshSig$;
helpers.prelude(module);

try {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.useToastContainer = useToastContainer;

  var _react = require("react");

  var _utils = require("../utils");

  var _eventManager = require("../core/eventManager");

  var _useKeeper = require("./useKeeper");

  var _toastContainerReducer = require("./toastContainerReducer");

  function useToastContainer(props) {
    const [, forceUpdate] = (0, _react.useReducer)(x => x + 1, 0);
    const [toast, dispatch] = (0, _react.useReducer)(_toastContainerReducer.reducer, []);
    const containerRef = (0, _react.useRef)(null);
    let toastCount = (0, _useKeeper.useKeeper)(0);
    let queue = (0, _useKeeper.useKeeper)([]);
    const collection = (0, _useKeeper.useKeeper)({});
    const instance = (0, _useKeeper.useKeeper)({
      toastKey: 1,
      displayedToast: 0,
      props,
      containerId: null,
      isToastActive: isToastActive,
      getToast: id => collection[id] || null
    });
    (0, _react.useEffect)(() => {
      instance.containerId = props.containerId;

      _eventManager.eventManager.cancelEmit(_eventManager.Event.WillUnmount).on(_eventManager.Event.Show, buildToast).on(_eventManager.Event.Clear, toastId => containerRef.current && removeToast(toastId)).on(_eventManager.Event.ClearWaitingQueue, clearWaitingQueue).emit(_eventManager.Event.DidMount, instance);

      return () => _eventManager.eventManager.emit(_eventManager.Event.WillUnmount, instance);
    }, []);
    (0, _react.useEffect)(() => {
      instance.isToastActive = isToastActive;
      instance.displayedToast = toast.length;

      _eventManager.eventManager.emit(_eventManager.Event.Change, toast.length, props.containerId);
    }, [toast]);
    (0, _react.useEffect)(() => {
      instance.props = props;
    });

    function isToastActive(id) {
      return toast.indexOf(id) !== -1;
    }

    function clearWaitingQueue({
      containerId
    }) {
      const {
        limit,
        enableMultiContainer
      } = instance.props;

      if (limit && (!containerId || instance.containerId === containerId && enableMultiContainer)) {
        toastCount -= queue.length;
        queue = [];
      }
    }

    function removeToast(toastId) {
      const queueLen = queue.length;
      toastCount = (0, _utils.hasToastId)(toastId) ? toastCount - 1 : toastCount - instance.displayedToast;
      if (toastCount < 0) toastCount = 0;

      if (queueLen > 0) {
        const freeSlot = (0, _utils.hasToastId)(toastId) ? 1 : instance.props.limit;

        if (queueLen === 1 || freeSlot === 1) {
          instance.displayedToast++;
          dequeueToast();
        } else {
          const toDequeue = freeSlot > queueLen ? queueLen : freeSlot;
          instance.displayedToast = toDequeue;

          for (let i = 0; i < toDequeue; i++) dequeueToast();
        }
      }

      dispatch({
        type: 'REMOVE',
        toastId
      });
    }

    function dequeueToast() {
      const {
        toastContent,
        toastProps,
        staleId
      } = queue.shift(); // ensure that exit transition has been completed, hence the timeout

      setTimeout(() => {
        appendToast(toastContent, toastProps, staleId);
      }, 500);
    }
    /**
     * check if a container is attached to the dom
     * check for multi-container, build only if associated
     * check for duplicate toastId if no update
     */


    function isNotValid({
      containerId,
      toastId,
      updateId
    }) {
      return !containerRef.current || instance.props.enableMultiContainer && containerId !== instance.props.containerId || instance.isToastActive(toastId) && updateId == null ? true : false;
    } // this function and all the function called inside needs to rely on ref(`useKeeper`)


    function buildToast(content, {
      delay,
      staleId,
      ...options
    }) {
      if (!(0, _utils.canBeRendered)(content) || isNotValid(options)) return;
      const {
        toastId,
        updateId
      } = options;
      const {
        props,
        isToastActive
      } = instance;

      const closeToast = () => removeToast(toastId);

      const isNotAnUpdate = !isToastActive(toastId);
      if (isNotAnUpdate) toastCount++;
      const toastProps = {
        toastId,
        updateId,
        key: options.key || instance.toastKey++,
        type: options.type,
        closeToast: closeToast,
        closeButton: options.closeButton,
        rtl: props.rtl,
        position: options.position || props.position,
        transition: options.transition || props.transition,
        className: (0, _utils.parseClassName)(options.className || props.toastClassName),
        bodyClassName: (0, _utils.parseClassName)(options.bodyClassName || props.bodyClassName),
        style: options.style || props.toastStyle,
        bodyStyle: options.bodyStyle || props.bodyStyle,
        onClick: options.onClick || props.onClick,
        pauseOnHover: (0, _utils.isBool)(options.pauseOnHover) ? options.pauseOnHover : props.pauseOnHover,
        pauseOnFocusLoss: (0, _utils.isBool)(options.pauseOnFocusLoss) ? options.pauseOnFocusLoss : props.pauseOnFocusLoss,
        draggable: (0, _utils.isBool)(options.draggable) ? options.draggable : props.draggable,
        draggablePercent: (0, _utils.isNum)(options.draggablePercent) ? options.draggablePercent : props.draggablePercent,
        closeOnClick: (0, _utils.isBool)(options.closeOnClick) ? options.closeOnClick : props.closeOnClick,
        progressClassName: (0, _utils.parseClassName)(options.progressClassName || props.progressClassName),
        progressStyle: options.progressStyle || props.progressStyle,
        autoClose: (0, _utils.getAutoCloseDelay)(options.autoClose, props.autoClose),
        hideProgressBar: (0, _utils.isBool)(options.hideProgressBar) ? options.hideProgressBar : props.hideProgressBar,
        progress: options.progress,
        role: (0, _utils.isStr)(options.role) ? options.role : props.role,

        deleteToast() {
          removeFromCollection(toastId);
        }

      };
      if ((0, _utils.isFn)(options.onOpen)) toastProps.onOpen = options.onOpen;
      if ((0, _utils.isFn)(options.onClose)) toastProps.onClose = options.onClose;
      let closeButton = props.closeButton;

      if (options.closeButton === false || (0, _utils.canBeRendered)(options.closeButton)) {
        closeButton = options.closeButton;
      } else if (options.closeButton === true) {
        closeButton = (0, _utils.canBeRendered)(props.closeButton) ? props.closeButton : true;
      }

      toastProps.closeButton = closeButton;
      let toastContent = content;

      if ( /*#__PURE__*/(0, _react.isValidElement)(content) && !(0, _utils.isStr)(content.type)) {
        toastContent = /*#__PURE__*/(0, _react.cloneElement)(content, {
          closeToast
        });
      } else if ((0, _utils.isFn)(content)) {
        toastContent = content({
          closeToast
        });
      } // not handling limit + delay by design. Waiting for user feedback first


      if (props.limit && props.limit > 0 && toastCount > props.limit && isNotAnUpdate) {
        queue.push({
          toastContent,
          toastProps,
          staleId
        });
      } else if ((0, _utils.isNum)(delay) && delay > 0) {
        setTimeout(() => {
          appendToast(toastContent, toastProps, staleId);
        }, delay);
      } else {
        appendToast(toastContent, toastProps, staleId);
      }
    }

    function appendToast(content, toastProps, staleId) {
      const {
        toastId
      } = toastProps;
      collection[toastId] = {
        content,
        props: toastProps
      };
      dispatch({
        type: 'ADD',
        toastId,
        staleId
      });
    }

    function removeFromCollection(toastId) {
      delete collection[toastId];
      forceUpdate();
    }

    function getToastToRender(cb) {
      const toastToRender = {};
      const toastList = props.newestOnTop ? Object.keys(collection).reverse() : Object.keys(collection);

      for (let i = 0; i < toastList.length; i++) {
        const toast = collection[toastList[i]];
        const {
          position
        } = toast.props;
        toastToRender[position] || (toastToRender[position] = []);
        toastToRender[position].push(toast);
      }

      return Object.keys(toastToRender).map(p => cb(p, toastToRender[p]));
    }

    return {
      getToastToRender,
      collection,
      containerRef,
      isToastActive
    };
  }

  helpers.postlude(module);
} finally {
  window.$RefreshReg$ = prevRefreshReg;
  window.$RefreshSig$ = prevRefreshSig;
}